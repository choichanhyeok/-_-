

> ### 1. 나는 고리타분하게 역사나 원칙 얘기하는 사람 아니고 예시를 들어 설명할거다. 
```
저자 曰: 
전통적인 방식을 따라 리팩터링의 역사와 여러 원칙등을 하나씩 나열할 수도 있지만 
누군가 이런 식으로 설명하는 걸 듣고 있자면 솔직히 살짝 졸렸다.

그러다 예시가 등장하면 정신이 드는데, 그제야 무슨 말을 하는지 와닿기 때문이다.
.. 예시가 있으면 명확해진다.
``` 

<br><br>


> ### 2. 근데 막상 해보니 쉽지 않았다. 😅 그래서 짧게 코드 쓸테니 대규모라고 알아서 상상해라
```
그런데 예시용 프로그램을 선정하다가 난관에 봉착했다.
프로그램이 너무 길면 설명이 복잡해지고 간단한 코드는 리팩터링 할 필요를 느끼기 어렵다.

.. 솔직히 이 책에 수록된 예처럼 간단한 프로그램은 굳이 내가 제시하는 리팩터링을 적용 할 필욘 없다.
근데 이 코드가 대규모 시스템의 일부라면 리팩터링을 하고 안 하고의 차이가 크니 .. 대규모 시스템 .. 상상하면서 따라오라.  
```


<br><br>


> ### 3. `포인트 적립`을 지원하는 희극과 비극 공연만 하는 극단 예시


<br>


- `연극.json` 
````
{
    "지저스_크라이_슈퍼스타": {"배우": "부처님", "장르": "액션활극"}
    "문어_게임": {"배우": "낙지", "장르": "로맨스"}
}
````
<br>

- `청구서.json`
```
[
    {
        "고객": "교황님",
        "관람한 연극 목록": [
            {
                "공연ID": 지저스_크라이_슈퍼스타,
                "관객수": 55
            },
            {
                "공연ID: 문어_게임,
                "관객수": 35
            }
        ]
    },
]
```

<br>

![img.png](이미지/공연료%20총%20결산%20전자%20두뇌.png)


.. 사실 관람한 공연 목록에 굳이 관객 수가 들어가는 이유는 모르겠으나 위 같은 데이터가 있다고 할 때 
위 데이터를 이용해 공연료 청구서를 출력한다고 한다.

<br>

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 미국 스타일(US)로 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        Map<String, String> 관람한_연극_정보 = 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
        if (관람한_연극_정보 == null) {
            throw new Exception("알 수 없는 공연 ID: " + 청구서_개별_연극_정보.가져오기_공연ID());
        }
        
        String 장르 = 관람한_연극_정보.get("장르");
        int 이번_공연_청구금액 = 0;

        switch (장르) {
            case "액션활극":
                이번_공연_청구금액 = 40000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                    이번_공연_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
                }
                break;

            case "로맨스":
                이번_공연_청구금액 = 30000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                    이번_공연_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
                }
                이번_공연_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
                break;

            default:
                throw new Exception("알 수 없는 장르: " + 장르);
        }

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(장르)) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }

        최종_청구_금액 += 관람한_연극_정보.get("이름") + ": " + 숫자_포맷.format(이번_공연_청구금액 / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 이번_공연_청구금액;
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}

```


.. 생각보다 뭐가 좀 복잡하다. 장르랑 관객수에 따라서 청구 금액도 달라지고 관객수에 따라서 적립금도 달라진다. 


<br><br>


> ### 4. 코드 어때요 ~? 지금은 괜찮지만 규모가 커지면 이 코드는 별로라고 생각한다. 
![img.png](이미지/왠지_두근거려요.png)

```
나는 이 상태로도 그럭저럭 쓸만하다는 생각이 든다.
프로그램이 너무 짧아서 특별히 애써 이해해야 할 구조도 없다.

.. 하지만 이런 코드가 수백 줄짜리 프로그램의 일부라면 간단한 인라인 함수 하나라도 이해하기가 쉽지 않다.

프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로 불평하는 것은 프로그램의 구조를 너무
미적인 기준으로만 판단하는 건 아닐까? 컴파일러는 코드가 지저분하든 개의치 않으니 말이다. 하지만 사람은 미적 상태에 민감하다.
```

저자는 이 코드를 개선하기 위해 몇가지 제안을 했다.

- a. 청구 내역을 HTML로 출력하는 기능이 필요하다.
  - 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야 하는 상황을 가정하자
  - 이 경우에 청구서_결과_조회 함수의 복잡도가 크게 증가한다. 
  - 대부분 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리하게 될 것이다.
  - 이 방법은 청구서 작성 로직을 변경할 때 마다 기존 함수와 HTML 버전 함수 모두를 수정해야 한다.
  - `로직을 변경할 일이 없다면` 이런 복사 붙여넣기도 괜찮지만 오래 사용할 프로그램이라면 중복 코드는 골칫거리다 된다.
    - (내 생각) 뭔 소리여 .. `변경되는 상태`가 되면 문제인거지 변경 안되는 상태로 오래 사용하면 문제 없을건데 ..  
```
public String 청구서_결과_조회_텍스트(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception { 
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n"; 

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        Map<String, String> 관람한_연극_정보 = 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
        String 장르 = 관람한_연극_정보.get("장르");
        int 이번_공연_청구금액 = 0;

        switch (장르) {
            case "액션활극":
                이번_공연_청구금액 = 40000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                    이번_공연_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
                }
                break;

            case "로맨스":
                이번_공연_청구금액 = 30000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                    이번_공연_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
                }
                이번_공연_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
                break;

            default:
                throw new Exception("알 수 없는 장르: " + 장르);
        }

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(장르)) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }

        최종_청구_금액 += 관람한_연극_정보.get("이름") + ": " + 숫자_포맷.format(이번_공연_청구금액 / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 이번_공연_청구금액;
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```
```
public String 청구서_결과_조회_HTML(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception { 
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "<h1>청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")</h1>\n"; 
    최종_청구_금액 += "<table>\n<tr><th>공연</th><th>좌석 수</th><th>금액</th></tr>\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        Map<String, String> 관람한_연극_정보 = 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
        String 장르 = 관람한_연극_정보.get("장르");
        int 이번_공연_청구금액 = 0;

        switch (장르) {
            case "액션활극":
                이번_공연_청구금액 = 40000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                    이번_공연_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
                }
                break;

            case "로맨스":
                이번_공연_청구금액 = 30000;
                if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                    이번_공연_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
                }
                이번_공연_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
                break;

            default:
                throw new Exception("알 수 없는 장르: " + 장르);
        }

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(장르)) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }

        최종_청구_금액 += "<tr><td>" + 관람한_연극_정보.get("이름") + "</td><td>" + 청구서_개별_연극_정보.가져오기_관객수() + "</td><td>" + 숫자_포맷.format(이번_공연_청구금액 / 100.0) + "</td></tr>\n";
        총_금액 += 이번_공연_청구금액;
    }

    최종_청구_금액 += "</table>\n";
    최종_청구_금액 += "<p>총액: " + 숫자_포맷.format(총_금액 / 100.0) + "</p>\n";
    최종_청구_금액 += "<p>적립 포인트: " + 적립_포인트 + "점</p>\n";

    return 최종_청구_금액;
} 
``` 



<br>

- b. 장르가 많아지면 가격 정책 맨날 바꿔야 하는데 위 처럼 HTML, 텍스트 버전 나누면 두개 다 수정해야 하고 복잡하다.
  - 배우들은 더 많은 장르를 연기하고 싶어할 수 있고 이 경우 공연료와 적립 포인트 계산법을 변경해야 한다.
  - 이렇게 공연 정책을 변경하려면 청구서_결과_조회_TEXT를 수정해야 하는데 
  - 방금 복사붙여넣기 했으니 청구서_결과_조회_HTML도 수정해야 한다.
  - 이 과정에서 수정할 부분은 찾기 어려워지고 수정 과정에서 실수할 가능성도 커진다.


<br><br>

> ### 5. 리팩터링을 시작하자
```
리팩터링의 첫 단계는 항상 똑같다.  ..  테스트 코드들부터 마련해야 한다.

리팩터링은 사람이 수행하기 때문에 언제든 실수할 수 있다. 프로그램이 클수록 수정 과정에서 예쌍치 못한 문제가 발생할 가능성이 크다.
```

- ## 청구서_결과_조회() 함수의 테스트를 구성하자.
- 테스트를 위한 데이터를 세팅하고 프레임워크를 이용해 자동화하기
  - 함수는 문자열을 반환하기에
  - 다양한 장르의 공연들로 구성된 공연료 청구서 몇개를 미리 작성해 문자열 형태로 준비하자
  - 청구서_결과_조회()가 반환한 문자열과 준비해둔 정답 문자열을 비교한다.
  - 이 과정을 테스트 프레임워크를 이용해 단축키 하나로 실행할 수 있도록 한다.



<br><br>


> ### 6. 청구서_결과_조회() 함수를 찢어버리자

![img.png](이미지/북극곰은%20코드를%20찢어.png)

statement()처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다.
여기선 중간에 switch문이 가장 먼저 눈에 띌 것이다. switch의 역할은 `공연 금액 계산`이니 이 이름으로 함수를 뽑아내자.


```
private int 공연_금액_계산(청구서_연극 청구서_개별_연극_정보, Map<String, String> 관람한_연극_정보) throws Exception {
    int 이번_연극_청구금액 = 0;
    String 관람한_연극_장르 = 관람한_연극_정보.get("장르");

    switch (관람한_연극_장르) {
        case "액션활극":
            이번_연극_청구금액 = 40000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                이번_연극_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
            }
            break;

        case "로맨스":
            이번_연극_청구금액 = 30000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                이번_연극_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
            }
            이번_연극_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
            break;

        default:
            throw new Exception("알 수 없는 장르: " + 관람한_연극_장르);
    }

    return 이번_연극_청구금액;
}
```

- 특정 컨텍스트를 함수로 빼낼 때 유효범위를 벗어나는 변수가 있는지 확인한다. (매개변수로 넣어줘야 하니까 당연한 거 아닌가?)
- 근데 중요한 건 값을 변경하지 않는 경우엔 매개변수로 전달하면 되는데 `이번_연극_청구금액`같이 함수 안에서 값이 변경되는 것들은 조심해서 다루어야 한다.

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception { 
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n"; 

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        Map<String, String> 관람한_연극_정보 = 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());

        // 공연 금액 계산
        int 이번_공연_청구금액 = 공연_금액_계산(청구서_개별_연극_정보, 관람한_연극_정보);

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(관람한_연극_정보.get("장르"))) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }

        최종_청구_금액 += 관람한_연극_정보.get("이름") + ": " + 숫자_포맷.format(이번_공연_청구금액 / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 이번_공연_청구금액;
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```

- `이런 수정 뒤엔 테스트 코드를 꼭 돌려보라`
- 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
- 리팩터링 자잘하게 한 번 할 때마다 커밋하는 습관 길러라.

이제 `공연_금액_계산`메서드에 `관람한_연극_정보`를 리팩토링 해보자.

- `청구서_개별_연극_정보`의 경우는 청구서_정보에서 리스트를 받아와 순회하며 받아온다. 
- 반면 `관람한_연극_정보`는 `청구서_개별_연극_정보`에서 공연ID를 받아와서 얻기 때문에 매개변수로 전달할 필요가 없다.
- 그냥 `공연_금액_계산` 메서드에서 다시 계산하면 된다.
- 이런 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나면 추출 작업이 복잡해져서 최대한 질의 함수로 바꿔 제거한다.

```
private Map<String, String> 관람한_연극_정보_추출 (청구서_연극 청구서_개별_연극_정보) {
    return 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
}
```

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception { 
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n"; 

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        Map<String, String> 관람한_연극_정보 = 관람한_연극_정보_추출(청구서_개별_연극_정보);

        ...
```

- 위 처럼 임시변수를 질의 함수로 바꿔줬으면 인라인 변수 그냥 제거해버리자.


```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception { 
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n"; 

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
        // Map<String, String> 관람한_연극_정보 = 관람한_연극_정보_추출(청구서_개별_연극_정보); <- 이걸 지워버린다.

        // 공연 금액 계산
        int 이번_공연_청구금액 = 공연_금액_계산(청구서_개별_연극_정보, 관람한_연극_정보);

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(관람한_연극_정보.get("장르"))) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }
                      /* 여기 있던 관람한_연극_정보.get("이름")을 대신해서 관람한_연극_정보_추출(청구서_개별_연극_정보)를 인라인 해준다. */
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(이번_공연_청구금액 / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 이번_공연_청구금액;
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```


```                                                                     
private int 공연_금액_계산(청구서_연극 청구서_개별_연극_정보, Map<String, String> 관람한_연극_정보) throws Exception {
    int 이번_연극_청구금액 = 0;

    switch (관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()) {
        case "액션활극":
            이번_연극_청구금액 = 40000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                이번_연극_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
            }
            break;

        case "로맨스":
            이번_연극_청구금액 = 30000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                이번_연극_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
            }
            이번_연극_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
            break;

        default:
            // throw new Exception("알 수 없는 장르: " + 관람한_연극_정보.get("장르"););
            throw new Exception("알 수 없는 장르: " + 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()); /* 이 부분에 인라인 변수 제거 */
    }

    return 이번_연극_청구금액;
}
```

- .. 이건 좀 의외다. 그냥 변수 하나 두고 쓰는게 더 깔끔하지 않나? 저렇게 함수 주렁주렁 달고 특정 장르값 가져오는 것보다? 
- 재사용성을 왜 없앤거지?
- 변수 인라인이 어떤 장점이 있는거야?


```
                              /* Map<String, String> 관람한_연극_정보  파라미터 제거 */
private int 공연_금액_계산(청구서_연극 청구서_개별_연극_정보) throws Exception {
    int 이번_연극_청구금액 = 0;

    switch (관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()) {
        case "액션활극":
            이번_연극_청구금액 = 40000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                이번_연극_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
            }
            break;

        case "로맨스":
            이번_연극_청구금액 = 30000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                이번_연극_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
            }
            이번_연극_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
            break;

        default:
            // throw new Exception("알 수 없는 장르: " + 관람한_연극_정보.get("장르"););
            throw new Exception("알 수 없는 장르: " + 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()); /* 이 부분에 인라인 변수 제거 */
    }

    return 이번_연극_청구금액;
}
```

![img.png](이미지/이게%20무슨%20일인데.png)


이게 먼 일이지 .. 갑자기 파라미터를 없애도 되는 상황이 되어버렸다.

- 어차피 관람한_연극_정보는 연극_정보에서 청구서_개별_연극에서 가져온 연극ID만 있으면 조회가 가능하다.
- 그니까 외부에서 연극 ID 가지고 청구서_개별_연극_정보만 받아서 조회 시켜주는 질의 함수 만들어두면
- 굳이 인자로 안넘겨줘도 함수 이용해서 값을 받아올 수 있는 것이다.
- 와 .. 개천재

```
방금 수행한 리팩터링에서 주목할 점이 몇 가지 있다. 이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 반해
리팩터링한 코드에서는 세 번이나 조회한다. 뒤에서 리팩터링과 성능의 관계를 자세히 설명하겠지만,
일단 지금 확인한 바로는 이렇게 변경해도 성능에 큰 영향은 없다. 설사 느려지더라도 제대로 리팩터링된 코드베이스는
그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.
```

- 어쨌든 임시 변수를 안쓴고 매번 조회한다는 건 연산을 더 한다는 의미구나 ..

```
지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 쉬워진다는 것이다.
유효범위를 신경 써야 할 대상이 줄어들기 때문이다. 실제로 나는 추출 작업 전에는 거의 항상 지역 변수부터 제거한다.
```

- 나는 변수를 지어두는게 좋은 줄 알았는데 전혀 엉뚱하게 생각하고 있었다는 걸 깨달았다.
- 앞으론 지역변수 다 조사버리고 연산을 3배 4배로 늘려버려야겠다.


```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
    
        // 공연 금액 계산
        // int 이번_공연_청구금액 = 공연_금액_계산(청구서_개별_연극_정보); /* 이것도 지워버리고 아래 인라인으로 */

        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(관람한_연극_정보.get("장르"))) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }                                                                                   // 여기에 인라인으로 넣어버린다.
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```
- 여기까지 봤을 때 그냥 임시변수 안쓰고 함수로 매번 계산하는건데, 왠지 모를 거부감이 들긴 한다.

.. 일단 여태까지 코드를 한번 정리해보자.


```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
    
        적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
        if ("희극".equals(관람한_연극_정보.get("장르"))) {
            적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
        }                                                                                  
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```

```
private int 공연_금액_계산(청구서_연극 청구서_개별_연극_정보) throws Exception {
    int 이번_연극_청구금액 = 0;

    switch (관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()) {
        case "액션활극":
            이번_연극_청구금액 = 40000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                이번_연극_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
            }
            break;

        case "로맨스":
            이번_연극_청구금액 = 30000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                이번_연극_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
            }
            이번_연극_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
            break;

        default:
            // throw new Exception("알 수 없는 장르: " + 관람한_연극_정보.get("장르"););
            throw new Exception("알 수 없는 장르: " + 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()); /* 이 부분에 인라인 변수 제거 */
    }

    return 이번_연극_청구금액;
}
```

```
private Map<String, String> 관람한_연극_정보_추출 (청구서_연극 청구서_개별_연극_정보) {
    return 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
}
```



.. 저자는 그냥 저 지역 변수를 다 없애야 속이 풀리는 거 같다. 처리해야 할게 2개 남았다는 거 보니까 총_금액이랑 적립_포인트를
처리하려는 거 같은데 적립_포인트의 경우 반복문을 돌 때마다 값을 누적해야 해서 까다롭다고 한다. 이걸 해결하기 위해 `적립_포인트` 
변수의 복제본을 초기화하고 계산 결과를 반환토록 한다고 한다.


```
private int 적립금_추출(청구서_연극 청구서_개별_연극_정보) {
  int 적립_포인트 = 0;

  적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
  if ("희극".equals(관람한_연극_정보.get("장르"))) {
      적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
  }        
  
  return 적립_포인트;
  
}
```

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    int 적립_포인트 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {
    
        적립_포인트 += 적립금_추출(청구서_개별_연극_정보);                                     
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```
- 위 코드들 처럼 적립 포인트 관련 로직을 쪼개버렸다. 
- 결국 적립 포인트 없애보자.

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {    
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    /* 성능상 불이익이 있더라도 이렇게 일단 별도 for문으로 빼주자 */
    int 적립_포인트 = 0;  /* 적립_포인트 변수도 반복문 바로 앞으로 가져다 놓자.
    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {        
        적립_포인트 += 적립금_추출(청구서_개별_연극_정보);                        
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```
- 위 처럼 값 갱신과 관련된 문장을 한데 모으면 임시 변수를 질의 함수로 바꾸기 수월해진다.
- 여태까지 처럼 함수로 추출해보자.

```
private int 적립금_총액_추출() {
  int 적립_포인트 = 0;

  for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {        
      적립_포인트 += 적립금_추출(청구서_개별_연극_정보);                        
  }
  
  return 적립_포인트;
  
}
```

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {    
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    /* 성능상 불이익이 있더라도 이렇게 일단 별도 for문으로 빼주자 */
    int 적립_포인트 = 적립금_총액_추출();

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립_포인트 + "점\n";

    return 최종_청구_금액;
}
```


- 자 .. 이제 함수 추출 했으니 지역 변수 없애버리게 바로 인라인 처리 해버리자.

```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {    
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립금_총액_추출() + "점\n"; // 적립_포인트 -> 적립금_총액_추출()로 인라인

    return 최종_청구_금액;
}
```

- 이제 슬슬 저자도 성능 관련해서 욕 먹을까 두려운 거 같다.
- 컴파일러 똑똑해져서 캐싱이 좋다고 하면서 보험을 들기 시작하는데
- 상황에 따라 다르겠지만 성능에 큰 영향을 주는 경우가 있는데그럼에도 본인은 리팩토링을 하는 편이라고 한다.

여태까지 배운 내용은 아래와 같은 절차로 이루어진다.


1. 반복문 쪼개기: 변수 값을 누적시키는 부분을 분리한다.
2. 문장 슬라이드하기: 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. 함수 추출하기: 별도 함수로 추출한다.
4. 변수 인라인하기: 기존 임시 변수 쓰던 거를 함수로 직접 호출하도록 한다. (여기서 중복 발생하는 경우 많아짐)




> ### 7. 난무하는 중첩함수

.. 잠시 멈춰서 여태까지 리팩토링 한 결과를 보자.


```
public String 청구서_결과_조회(청구서 청구서_정보, Map<String, Map<String>> 연극_정보) throws Exception {
    int 총_금액 = 0;
    String 최종_청구_금액 = "청구 내역 (고객명: " + 청구서_정보.가져오기_고객_이름() + ")\n";

    /* 한국 스타일 통화 포맷 */
    NumberFormat 숫자_포맷 = NumberFormat.getCurrencyInstance(Locale.KOREA);

    for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {    
        최종_청구_금액 += 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_이름() + ": " + 숫자_포맷.format(공연_금액_계산(청구서_개별_연극_정보). / 100.0) + " (" + 청구서_연극_정보.가져오기_관객수() + "석)\n";
        총_금액 += 공연_금액_계산(청구서_개별_연극_정보); // 여기도 인라인으로
    }

    최종_청구_금액 += "총액: " + 숫자_포맷.format(총_금액 / 100.0) + "\n";
    최종_청구_금액 += "적립 포인트: " + 적립금_총액_추출() + "점\n"; // 적립_포인트 -> 적립금_총액_추출()로 인라인

    return 최종_청구_금액;
}
```

```
private int 공연_금액_계산(청구서_연극 청구서_개별_연극_정보) throws Exception {
    int 이번_연극_청구금액 = 0;

    switch (관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()) {
        case "액션활극":
            이번_연극_청구금액 = 40000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 30) {
                이번_연극_청구금액 += 1000 * (청구서_개별_연극_정보.가져오기_관객수() - 30);
            }
            break;

        case "로맨스":
            이번_연극_청구금액 = 30000;
            if (청구서_개별_연극_정보.가져오기_관객수() > 20) {
                이번_연극_청구금액 += 300 * (청구서_개별_연극_정보.가져오기_관객수() - 20);
            }
            이번_연극_청구금액 += 300 * 청구서_개별_연극_정보.가져오기_관객수();
            break;

        default:
            // throw new Exception("알 수 없는 장르: " + 관람한_연극_정보.get("장르"););
            throw new Exception("알 수 없는 장르: " + 관람한_연극_정보_추출(청구서_개별_연극_정보).가져오기_장르()); /* 이 부분에 인라인 변수 제거 */
    }

    return 이번_연극_청구금액;
}
```

```
private Map<String, String> 관람한_연극_정보_추출 (청구서_연극 청구서_개별_연극_정보) {
    return 연극_정보.get(청구서_개별_연극_정보.가져오기_공연ID());
}
```

```
private int 적립금_추출(청구서_연극 청구서_개별_연극_정보) {
  int 적립_포인트 = 0;

  적립_포인트 += Math.max(청구서_개별_연극_정보.가져오기_관객수() - 30, 0);
  if ("희극".equals(관람한_연극_정보.get("장르"))) {
      적립_포인트 += Math.floor(청구서_개별_연극_정보.가져오기_관객수() / 5);
  }        
  
  return 적립_포인트;
  
}
```

```
private int 적립금_총액_추출() {
  int 적립_포인트 = 0;

  for (청구서_연극 청구서_개별_연극_정보 : 청구서_정보.가져오기_청구서_연극_목록()) {        
      적립_포인트 += 적립금_추출(청구서_개별_연극_정보);                        
  }
  
  return 적립_포인트;
  
}
```

보면 최상위 메서드인 `청구서_결과_조회`는 이제 단 7줄 뿐이다. 이 녀석은 출력할 문장을 생성하는 책임만 가지고 있다.
계산 로직은 모두 여러개의 보조 함수로 빠졌고 결과적으로 각 계산 과정은 물론 전체 흐름을 이해하기가 훨씬 쉬워졌다.
`저자 白`



> ### 8. 계산 단계와 포맷팅 단계 분리하기

- 이제 어느정도 구조가 편해졌으니 최초의 문제였던 `HTML 분리` 문제를 해결해보자.
- 이 작업을 수행하기 위해 필요한 일은 `중첩 함수` 어떻게 다룰지 생각하는 것이다.

지금 청구서_결과_조회()의 중첩 함수로 각 함수들이 들어가 있는데 



# 안돼 .. 이런식으론 얼른 포기하고 커밋으로 따라 치기만 진행하자. 



![img.png](이미지/이러다%20다죽어.png)
